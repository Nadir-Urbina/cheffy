import 'recipe_model.dart';

/// Information about a YouTube video
class VideoInfo {
  final String videoId;
  final String title;
  final String? description;
  final String? channelName;
  final String? thumbnailUrl;
  final Duration? duration;
  final DateTime? uploadDate;

  VideoInfo({
    required this.videoId,
    required this.title,
    this.description,
    this.channelName,
    this.thumbnailUrl,
    this.duration,
    this.uploadDate,
  });

  /// Get high quality thumbnail URL
  String get highQualityThumbnail =>
      thumbnailUrl ?? 'https://img.youtube.com/vi/$videoId/maxresdefault.jpg';

  /// Get standard thumbnail URL (fallback)
  String get standardThumbnail =>
      'https://img.youtube.com/vi/$videoId/hqdefault.jpg';

  /// Get the YouTube watch URL
  String get watchUrl => 'https://www.youtube.com/watch?v=$videoId';
}

/// A segment of transcript with timing information
class TranscriptSegment {
  final String text;
  final Duration start;
  final Duration end;

  TranscriptSegment({
    required this.text,
    required this.start,
    required this.end,
  });

  @override
  String toString() => text;
}

/// Complete transcript of a video
class VideoTranscript {
  final String videoId;
  final String languageCode;
  final List<TranscriptSegment> segments;
  final bool isAutoGenerated;

  VideoTranscript({
    required this.videoId,
    required this.languageCode,
    required this.segments,
    this.isAutoGenerated = false,
  });

  /// Get the full transcript as a single string
  String get fullText => segments.map((s) => s.text).join(' ');

  /// Get transcript with timestamps (useful for debugging)
  String get formattedText {
    return segments.map((s) {
      final mins = s.start.inMinutes;
      final secs = s.start.inSeconds % 60;
      return '[$mins:${secs.toString().padLeft(2, '0')}] ${s.text}';
    }).join('\n');
  }

  /// Check if transcript is empty or too short
  bool get isEmpty => segments.isEmpty || fullText.trim().length < 50;
}

/// Result of video recipe extraction
class VideoRecipeResult {
  final VideoInfo videoInfo;
  final Recipe? recipe;
  final String? error;
  final bool usedVisionFallback;
  final VideoTranscript? transcript;

  VideoRecipeResult({
    required this.videoInfo,
    this.recipe,
    this.error,
    this.usedVisionFallback = false,
    this.transcript,
  });

  /// Create a successful result
  factory VideoRecipeResult.success({
    required VideoInfo videoInfo,
    required Recipe recipe,
    bool usedVisionFallback = false,
    VideoTranscript? transcript,
  }) {
    return VideoRecipeResult(
      videoInfo: videoInfo,
      recipe: recipe,
      usedVisionFallback: usedVisionFallback,
      transcript: transcript,
    );
  }

  /// Create an error result
  factory VideoRecipeResult.failure({
    required VideoInfo videoInfo,
    required String error,
  }) {
    return VideoRecipeResult(
      videoInfo: videoInfo,
      error: error,
    );
  }

  bool get hasError => error != null;
  bool get hasRecipe => recipe != null;
}

/// Status updates during video processing
enum VideoProcessingStatus {
  fetchingVideo,
  fetchingTranscript,
  extractingFrames,
  analyzingContent,
  parsingRecipe,
  complete,
  error,
}

extension VideoProcessingStatusExtension on VideoProcessingStatus {
  String get message {
    switch (this) {
      case VideoProcessingStatus.fetchingVideo:
        return 'Fetching video information...';
      case VideoProcessingStatus.fetchingTranscript:
        return 'Getting video transcript...';
      case VideoProcessingStatus.extractingFrames:
        return 'No transcript found, analyzing video frames...';
      case VideoProcessingStatus.analyzingContent:
        return 'AI is analyzing the recipe...';
      case VideoProcessingStatus.parsingRecipe:
        return 'Extracting recipe details...';
      case VideoProcessingStatus.complete:
        return 'Recipe extracted!';
      case VideoProcessingStatus.error:
        return 'Something went wrong';
    }
  }
}
